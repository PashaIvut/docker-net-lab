# Лабораторная работа 4: Сетевое взаимодействие контейнеров Docker

## Ход работы

### Задание 1. Исследование сетей Docker на хосте

#### Определим, какие сети созданы в Docker по умолчанию на машине.
<img width="710" height="121" alt="image" src="https://github.com/user-attachments/assets/b4395d3b-0863-4555-a931-eb5a5912428f" />

#### 1.2. Информация о сети bridge по умолчанию
С помощью команды **docker network inspect bridge** определить подсеть (диапазон адресов) и адрес шлюза сети **bridge**.
<img width="988" height="419" alt="image" src="https://github.com/user-attachments/assets/7fed09ff-f458-4393-bdf6-350fcad58eca" />

**Bridge** - внутренняя сеть Docker по умолчанию. Контейнеры получают внутренние IP-адреса и могут общаться друг с другом по IP или по имени контейнера. Для доступа извне требуется проброс портов. Обеспечивает сетевую изоляцию контейнеров от хоста и внешней сети.

#### 1.3. Назначение стандартных сетей
**Host** — использование сети хоста без изоляции. Контейнер использует IP-адрес хоста напрямую и делит с ним сетевой стек. Параметр `-p` не нужен и не работает. Сетевая изоляция между хостом и контейнером отсутствует.

**None** — контейнер без сети. Контейнер не имеет IP в Docker-сетях, не может выйти в интернет и не может связаться с другими контейнерами. Используется для максимальной изоляции или отладки, когда сеть не нужна.

---

### Задание 2. Публикация порта контейнера

#### 2.1. Запуск веб-сервера с пробросом порта
Запустим контейнер с помощью **docker run -d -p 8080:80 --name web-server nginx**.
<img width="964" height="308" alt="image" src="https://github.com/user-attachments/assets/fc58d7c3-bb42-433d-9815-3837ae8bed87" />
- **-p 8080:80** — проброс порта (хост:контейнер)

#### 2.2. Проверка доступности сервиса
Откроем в браузере: http://localhost:8080.
<img width="1524" height="559" alt="image" src="https://github.com/user-attachments/assets/8294684c-a591-499c-99aa-218ff72f061e" />

---

### Задание 3. Пользовательская bridge-сеть и взаимодействие по имени

#### 3.1. Создание пользовательской сети
Создадим пользовательскую мостовую сеть с помощью **docker network create --driver bridge my-app-net**.
<img width="782" height="57" alt="image" src="https://github.com/user-attachments/assets/a87f79e6-9ac4-4235-b9d5-1bb77e905129" />

Проверка.                                                                                                                   
<img width="707" height="149" alt="image" src="https://github.com/user-attachments/assets/321e869c-fa0e-4f7c-99b9-9f9e439dbd4d" />
<img width="982" height="606" alt="image" src="https://github.com/user-attachments/assets/0cf324b3-c251-4c32-bd07-9529f8af4701" />

#### 3.2. Запуск контейнеров в пользовательской сети
Запустим контейнер db (например, Redis).
<img width="795" height="55" alt="image" src="https://github.com/user-attachments/assets/d0ac68c7-89b9-404b-ad94-22fa5954b506" />
- **--network my-app-net** — подключение контейнера к пользовательской сети **my-app-net**.

Запутим контейнер web.
<img width="969" height="210" alt="image" src="https://github.com/user-attachments/assets/8f82b0ce-594e-4bbe-be06-b3a3fcb101d8" />
- **--network my-app-net** — подключение контейнера к пользовательской сети **my-app-net**.
- **curlimages/curl** — образ, содержащий утилиту **curl** для выполнения HTTP-запросов.
- **sh** — команда для запуска shell-оболочки внутри контейнера.

#### 3.3. Проверка взаимодействия по имени
Внутри контейнера **web** выполним **ping -c 3 db**.
<img width="706" height="235" alt="image" src="https://github.com/user-attachments/assets/b98d6352-5ed1-4edd-a4a5-a05e4d39dcc8" />

- **-c 3** (count) — отправляет указанное количество пакетов и завершает работу. Без этого флага **ping** работает бесконечно до прерывания.

#### 3.4. Проверка IP-адресов
**db** — используется для обращения между контейнерами.                                                                 
<img width="654" height="107" alt="image" src="https://github.com/user-attachments/assets/1683190e-5334-4452-b1ee-2243aee14e6b" />                                                     
Внутри **web** для проверки взаимодействия использовали именно имя, а не IP.

Если удалить контейнер **db**, а затем создать новый, то IP изменится, но имя останется прежним. Обращение по имени все еще будет работать.

---

### Задание 4. Изоляция контейнера

#### 4.1. Запуск изолированного контейнера
С помощью команды **docker run -it --network none --name isolated alpine sh** запустим третий контейнер.
<img width="969" height="169" alt="image" src="https://github.com/user-attachments/assets/a366ed3c-da04-4945-aade-23ea6eaa7aa1" />

#### 4.2. Попытка обращения к сервису db
Попробуем из этого контейнера обратиться к сервису **db**:
<img width="957" height="221" alt="image" src="https://github.com/user-attachments/assets/dd6c8ef4-e722-4d98-8867-675cebf37bb2" />

Ожидаемо. Изолированный контейнер не может обратиться к **db**.

### Выводы

#### Чем отличаются стандартные сети Docker друг от друга
**Основное отличие:** уровень сетевой изоляции — от полной изоляции (**none**) через изолированную внутреннюю сеть (**bridge**) до отсутствия изоляции (**host**).

---

#### Зачем создавать собственные сети
Собственные сети нужны, чтобы разделить контейнеры на группы. Например, веб-сервер и база данных одного приложения могут быть в одной сети и общаться друг с другом, а контейнеры другого приложения — в другой сети и не видеть первую группу. Это повышает безопасность и помогает организовать работу нескольких приложений на одном хосте.
---

#### Как организовать взаимодействие контейнеров по имени

1. **Создать пользовательскую bridge-сеть:**
   ```bash
   docker network create --driver bridge my-app-net
   ```

2. **Запустить контейнеры в этой сети с именами:**
   ```bash
   docker run -d --network my-app-net --name db redis
   docker run -it --network my-app-net --name web curlimages/curl sh
   ```

3. **Использовать имена контейнеров для обращения:**
   - Внутри контейнера **web** можно обращаться к контейнеру **db** по имени: **ping db** и т.д.
   - Docker автоматически разрешает имена через встроенный DNS-сервер

4. **Преимущества использования имен:**
   - **Стабильность** — имя контейнера не меняется при пересоздании, в отличие от IP-адреса
   - **Удобство** — не нужно запоминать или искать IP-адреса
   - **Гибкость** — при изменении IP-адреса контейнера (например, после перезапуска) обращение по имени продолжает работать






